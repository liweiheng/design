#单例常见的设计模式
##1懒汉
###在类被加载的时候创建单例类的对象，类加载器负责加载类，并会保证只有一个线程在实例化单例类，也可以保证另一个类在加载的时候如果需要使用到单例类的实例时，单例类已经被初始化了。
##2静态内部类
###当类Singleton被加载的时候，并不会实例化Singleton，因为初始化语句是写在内部类SingletonHolder中，如果没有用户主动调用getInstance()方法，Singleton是不会被实例化的，这样，我们可以控制单例类实例化的时间
##3饿汉
###该模式在类被加载的时候实例化单例类，具体单例类什么时候被加载这个很难说，所以称这个模式为饿汉模式，它没有懒加载的效果
##4枚举
###最大的优点就是防止通过反射调用构造函数，和提供了自动序列化机制防止了通过反序列化重新创建新的对象。缺点是需要的内存两倍于静态常量

###---------------------------------------------------------------------------------------------------------------------------------------------------------
#破坏单例模式的方式有
##1反射
###如果要抵御这种攻击，要防止构造函数被成功调用两次。需要在构造函数中对实例化次数进行统计，大于一次就抛出异常。
##2序列化
###通过对Singleton的序列化与反序列化得到的对象是一个新的对象，这就破坏了Singleton的单例性。因为序列化会通过反射调用无参数的构造方法创建一个新的对象。 防止措施：在Singleton中定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。


#prototype module下是原型模式克隆的一种写法
###原型模式的优缺点：
 优点：（1）：当创建对象的实例较为复杂的时候，使用原型模式可以简化对象的创建过程，通过复制一个已有的实例可以提高实例的创建效率。
   
   　　（2）：扩展性好，由于原型模式提供了抽象原型类，在客户端针对抽象原型类进行编程，而将具体原型类写到配置文件中，增减或减少产品对原有系统都没有影响。
   
   　　（3）：原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式不需要这样，圆形模式中产品的复制是通过封装在类中的克隆方法实现的，无需专门的工厂类来创建产品。
   
   　　（4）：可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用(例如恢复到历史某一状态)，可辅助实现撤销操作。
   
 缺点：（1）：需要为每一个类配置一个克隆方法，而且该克隆方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违反了开闭原则。
   
   　　（2）：在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重签到引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。
  原型模式的适用环境：
   
   　　1：创建新对象成本较大（例如初始化时间长，占用CPU多或占太多网络资源），新对象可以通过复制已有对象来获得，如果相似对象，则可以对其成员变量稍作修改。
   
   　　2：系统要保存对象的状态，而对象的状态很小。
   
   　　3：需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的组合状态，通过复制原型对象得到新实例可以比使用构造函数创建一个新实例更加方便。
   